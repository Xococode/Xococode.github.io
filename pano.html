<script type="module">
    import * as THREE from 'three';
    import { VRButton } from 'three/addons/webxr/VRButton.js';

    let camera, scene, renderer, sphere, clock;
    let moveForward = false, moveBackward = false, moveLeft = false, moveRight = false;
    let rotationX = 0, rotationY = 0;
    let velocity = new THREE.Vector3();

    init();

    function init() {
        const container = document.getElementById('container');

        clock = new THREE.Clock();

        scene = new THREE.Scene();
        scene.background = new THREE.Color(0x101010);

        const light = new THREE.AmbientLight(0xffffff, 3);
        scene.add(light);

        camera = new THREE.PerspectiveCamera(70, window.innerWidth / window.innerHeight, 1, 2000);
        scene.add(camera);

        const panoSphereGeo = new THREE.SphereGeometry(6, 256, 256);
        const panoSphereMat = new THREE.MeshStandardMaterial({
            side: THREE.BackSide,
            displacementScale: -4.0
        });

        sphere = new THREE.Mesh(panoSphereGeo, panoSphereMat);

        const manager = new THREE.LoadingManager();
        const loader = new THREE.TextureLoader(manager);

        loader.load('https://threejs.org/examples/textures/kandao3.jpg', function (texture) {
            texture.colorSpace = THREE.SRGBColorSpace;
            texture.minFilter = THREE.NearestFilter;
            texture.generateMipmaps = false;
            sphere.material.map = texture;
        });

        loader.load('https://threejs.org/examples/textures/kandao3_depthmap.jpg', function (depth) {
            depth.minFilter = THREE.NearestFilter;
            depth.generateMipmaps = false;
            sphere.material.displacementMap = depth;
        });

        manager.onLoad = function () {
            scene.add(sphere);
        };

        renderer = new THREE.WebGLRenderer();
        renderer.setPixelRatio(window.devicePixelRatio);
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setAnimationLoop(animate);
        renderer.xr.enabled = true;
        renderer.xr.setReferenceSpaceType('local');
        container.appendChild(renderer.domElement);

        document.body.appendChild(VRButton.createButton(renderer));

        window.addEventListener('resize', onWindowResize);
        document.addEventListener('keydown', onKeyDown);
        document.addEventListener('keyup', onKeyUp);
        container.addEventListener('mousemove', onMouseMove);
    }

    function onWindowResize() {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
    }

    function onKeyDown(event) {
        switch (event.code) {
            case 'KeyW': moveForward = true; break;
            case 'KeyS': moveBackward = true; break;
            case 'KeyA': moveLeft = true; break;
            case 'KeyD': moveRight = true; break;
        }
    }

    function onKeyUp(event) {
        switch (event.code) {
            case 'KeyW': moveForward = false; break;
            case 'KeyS': moveBackward = false; break;
            case 'KeyA': moveLeft = false; break;
            case 'KeyD': moveRight = false; break;
        }
    }

    function onMouseMove(event) {
        const movementX = event.movementX || event.mozMovementX || event.webkitMovementX || 0;
        const movementY = event.movementY || event.mozMovementY || event.webkitMovementY || 0;

        rotationY -= movementX * 0.002;
        rotationX -= movementY * 0.002;

        rotationX = Math.max(-Math.PI / 2, Math.min(Math.PI / 2, rotationX));
    }

    function animate() {
        if (!renderer.xr.isPresenting) {
            const delta = clock.getDelta();

            velocity.x -= velocity.x * 10.0 * delta;
            velocity.z -= velocity.z * 10.0 * delta;

            if (moveForward) velocity.z -= 400.0 * delta;
            if (moveBackward) velocity.z += 400.0 * delta;
            if (moveLeft) velocity.x -= 400.0 * delta;
            if (moveRight) velocity.x += 400.0 * delta;

            const direction = new THREE.Vector3();
            direction.z = velocity.z * delta;
            direction.x = velocity.x * delta;

            camera.rotation.x = rotationX;
            camera.rotation.y = rotationY;
            camera.translateX(direction.x);
            camera.translateZ(direction.z);
        }

        renderer.render(scene, camera);
    }
</script>
