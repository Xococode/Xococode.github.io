<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Mundo VR para Meta Quest y PC</title>
  <style>
    body { margin: 0; overflow: hidden; }
  </style>
</head>
<body>
  <script type="module">
    import * as THREE from 'https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.module.js';
    import { VRButton } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/webxr/VRButton.js';
    import { OrbitControls } from 'https://cdn.jsdelivr.net/npm/three@0.157.0/examples/jsm/controls/OrbitControls.js';

    // Escena
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0x87CEEB);

    // Cámara
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    camera.position.set(0, 1.6, 3); // Altura estándar de usuario VR

    // Renderer
    const renderer = new THREE.WebGLRenderer({ antialias: true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.xr.enabled = true;
    document.body.appendChild(renderer.domElement);

    // Botón VR
    document.body.appendChild(VRButton.createButton(renderer));

    // Controles de Órbita (Solo PC)
    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;
    controls.dampingFactor = 0.1;
    controls.screenSpacePanning = false;
    controls.minDistance = 1;
    controls.maxDistance = 20;

    // Suelo
    const planeGeometry = new THREE.PlaneGeometry(10, 10);
    const planeMaterial = new THREE.MeshStandardMaterial({ color: 0x7BC8A4 });
    const plane = new THREE.Mesh(planeGeometry, planeMaterial);
    plane.rotation.x = -Math.PI / 2;
    plane.receiveShadow = true;
    scene.add(plane);

    // Luz Ambiental
    const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
    scene.add(ambientLight);

    // Luz Direccional
    const directionalLight = new THREE.DirectionalLight(0xffffff, 1);
    directionalLight.position.set(5, 10, 7.5);
    scene.add(directionalLight);

    // Esfera Animada
    const sphereGeometry = new THREE.SphereGeometry(0.5, 32, 32);
    const sphereMaterial = new THREE.MeshStandardMaterial({ color: 0xEF2D5E });
    const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);
    sphere.position.set(0, 1.5, -2);
    scene.add(sphere);

    // Cubo Interactivo
    const cubeGeometry = new THREE.BoxGeometry(1, 1, 1);
    const cubeMaterial = new THREE.MeshStandardMaterial({ color: 0xffd700 });
    const interactiveCube = new THREE.Mesh(cubeGeometry, cubeMaterial);
    interactiveCube.position.set(0, 1, -5);
    scene.add(interactiveCube);

    // Raycaster y Vector para Interacciones
    const raycaster = new THREE.Raycaster();
    const mouse = new THREE.Vector2();

    // Controladores VR
    const controllers = [];
    for (let i = 0; i < 2; i++) {
      const controller = renderer.xr.getController(i);
      controller.addEventListener('selectstart', () => interactWithCube(controller));
      scene.add(controller);
      controllers.push(controller);
    }

    // Función para Interactuar con el Cubo (VR)
    function interactWithCube(controller) {
      const tempMatrix = new THREE.Matrix4();
      tempMatrix.identity().extractRotation(controller.matrixWorld);

      raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
      raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);

      const intersects = raycaster.intersectObject(interactiveCube);
      if (intersects.length > 0) {
        interactiveCube.material.color.setHex(Math.random() * 0xffffff);
      }
    }

    // Función para Interactuar con el Cubo (Mouse)
    function onMouseClick(event) {
      // Obtener coordenadas del mouse
      mouse.x = (event.clientX / window.innerWidth) * 2 - 1;
      mouse.y = -(event.clientY / window.innerHeight) * 2 + 1;

      // Lanzar un rayo desde la cámara hacia la escena
      raycaster.setFromCamera(mouse, camera);
      const intersects = raycaster.intersectObject(interactiveCube);

      if (intersects.length > 0) {
        // Cambiar el color del cubo
        interactiveCube.material.color.setHex(Math.random() * 0xffffff);
      }
    }

    window.addEventListener('click', onMouseClick);

    // Animación de la Esfera
    let angle = 0;
    function animateSphere() {
      angle += 0.01;
      sphere.position.y = 1.5 + Math.sin(angle) * 0.5;
    }

    // Movimiento del Usuario
    const keys = { w: false, a: false, s: false, d: false };
    const speed = 2; // Velocidad de movimiento

    // Evento de Teclado
    window.addEventListener('keydown', (event) => {
      if (event.key in keys) keys[event.key] = true;
    });

    window.addEventListener('keyup', (event) => {
      if (event.key in keys) keys[event.key] = false;
    });

    // Función para Moverse con Teclado (PC)
    function moveWithKeyboard(delta) {
      const direction = new THREE.Vector3();
      if (keys.w) direction.z -= 1;
      if (keys.s) direction.z += 1;
      if (keys.a) direction.x -= 1;
      if (keys.d) direction.x += 1;
      direction.normalize();

      // Movimiento basado en la orientación de la cámara
      const moveX = direction.x * speed * delta;
      const moveZ = direction.z * speed * delta;

      // Calcular dirección relativa a la cámara
      const angle = camera.rotation.y;
      const sin = Math.sin(angle);
      const cos = Math.cos(angle);

      camera.position.x += (moveX * cos - moveZ * sin);
      camera.position.z += (moveX * sin + moveZ * cos);
    }

    // Función para Moverse con Controladores VR
    function moveWithVR(delta) {
      const session = renderer.xr.getSession();
      if (!session) return;

      const inputSources = session.inputSources;
      inputSources.forEach((inputSource) => {
        if (inputSource.gamepad) {
          const axes = inputSource.gamepad.axes;
          const [xAxis, zAxis] = axes;

          // Ignorar pequeños movimientos (deadzone)
          const threshold = 0.1;
          if (Math.abs(xAxis) < threshold && Math.abs(zAxis) < threshold) return;

          const direction = new THREE.Vector3();
          camera.getWorldDirection(direction);
          direction.y = 0;
          direction.normalize();

          const moveForward = direction.clone().multiplyScalar(-zAxis * speed * delta);
          const moveRight = new THREE.Vector3(direction.z, 0, -direction.x).multiplyScalar(xAxis * speed * delta);

          camera.position.add(moveForward).add(moveRight);
        }
      });
    }

    // Control de Animación Principal
    const clock = new THREE.Clock();

    function animate() {
      renderer.setAnimationLoop(() => {
        const delta = clock.getDelta();

        // Actualizar controles de órbita solo si no está en VR
        if (!renderer.xr.isPresenting) {
          controls.update();
        }

        // Movimiento
        moveWithKeyboard(delta);
        moveWithVR(delta);

        // Animación de la esfera
        animateSphere();

        // Renderizar
        renderer.render(scene, camera);
      });
    }

    // Ajuste Dinámico al Tamaño de la Ventana
    window.addEventListener('resize', () => {
      camera.aspect = window.innerWidth / window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });

    animate();
  </script>
</body>
</html>
